// Generated by CoffeeScript 1.6.3
(function() {
  var pathUtil,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  pathUtil = require('path');

  module.exports = function(BasePlugin) {
    var RestAPI, _ref;
    return RestAPI = (function(_super) {
      __extends(RestAPI, _super);

      function RestAPI() {
        _ref = RestAPI.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      RestAPI.prototype.name = 'restapi';

      RestAPI.prototype.config = {
        channel: '/restapi',
        maxFilenameLen: 40,
        injectHelper: null,
        collectionPathMap: null
      };

      RestAPI.prototype.getCollectionPath = function(collectionName) {
        var collectionPath, config, defaultCollectionPath, docpadConfig, _ref1, _ref2, _ref3;
        config = this.getConfig();
        docpadConfig = this.docpad.getConfig();
        collectionPath = ((_ref1 = docpadConfig[collectionName + 'Paths']) != null ? _ref1[0] : void 0) || ((_ref2 = config.collectionPathMap) != null ? _ref2[collectionName] : void 0);
        defaultCollectionPath = (_ref3 = docpadConfig['documentsPaths']) != null ? _ref3[0] : void 0;
        if (collectionPath === null) {
          docpad.log('warn', "The file path for the collection " + collectionName + " could not be determined, defaulting to " + defaultCollectionPath);
        }
        return collectionPath || defaultCollectionPath;
      };

      RestAPI.prototype.serverExtend = function(opts) {
        var channel, createFileFromRequest, deleteFilesFromRequest, docpad, getFilesFromRequest, getUniqueRelativePath, plugin, prepareCollection, prepareCollections, prepareFile, sendError, sendSuccessData, sendSuccessMessage, server, updateFileFromRequest;
        plugin = this;
        docpad = this.docpad;
        server = opts.server;
        channel = this.getConfig().channel;
        sendSuccessData = function(res, data, message) {
          return res.send({
            success: true,
            message: message || "Action completed successfully",
            data: data
          });
        };
        sendSuccessMessage = function(res, message) {
          return res.send({
            success: true,
            message: message
          });
        };
        sendError = function(res, err) {
          return res.send({
            success: false,
            message: err.message + ': \n' + err.stack.toString()
          });
        };
        prepareFile = function(file, additionalFields) {
          var field, fields, result, _i, _len, _ref1;
          result = {};
          fields = ['id', 'filename', 'relativePath', 'url', 'urls', 'contentType', 'encoding', 'source', 'content', 'contentRendered', 'date'];
          if (additionalFields == null) {
            additionalFields = [];
          }
          if (!Array.isArray(additionalFields)) {
            additionalFields = String(additionalFields).split(/[,\s]+/);
          }
          if (additionalFields.length === 1 && additionalFields[0] === 'all') {
            result = file.toJSON();
          } else {
            result.meta = file.getMeta().toJSON();
            _ref1 = fields.concat(additionalFields);
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              field = _ref1[_i];
              result[field] = file.get(field);
            }
          }
          if (result.meta.layout) {
            result.meta.layout = file.get('layoutRelativePath');
          }
          return result;
        };
        prepareCollection = function(collection, additionalFields) {
          var result;
          result = [];
          collection.each(function(file) {
            return result.push(prepareFile(file, additionalFields));
          });
          return result;
        };
        prepareCollections = function() {
          var addCollection, result;
          result = [];
          addCollection = function(collection) {
            var relativePaths;
            relativePaths = [];
            collection.each(function(model) {
              var relativePath;
              relativePath = model.get('relativePath');
              if (relativePath) {
                return relativePaths.push(relativePath);
              }
            });
            return result.push({
              name: collection.options.name,
              length: collection.length,
              relativePaths: relativePaths
            });
          };
          docpad.eachCollection(addCollection);
          return result;
        };
        getUniqueRelativePath = function(relativePath) {
          var basename, extensions, file, parts, relativeDirPath, result;
          result = relativePath;
          extensions = relativePath.replace(/^.+?\./, '');
          while ((file = docpad.getDatabase().where({
              relativeBase: result.replace(/\..*$/, '')
            })[0])) {
            basename = file.get('basename');
            relativeDirPath = file.get('relativeDirPath');
            parts = /^(.+?)-([0-9]+)$/.exec(basename);
            if (parts) {
              basename = parts[1] + '-' + (parseInt(parts[2], 10) + 1);
            } else {
              basename += '-2';
            }
            result = relativeDirPath + '/' + basename;
            if (extensions) {
              result += '.' + extensions;
            }
          }
          return result;
        };
        getFilesFromRequest = function(req, next) {
          var collection, collectionName, err, extension, files, filter, limit, mime, offset, page, pageOpts, queryOpts, relativePath, result, sortOpts, _ref1, _ref2;
          files = null;
          queryOpts = null;
          sortOpts = null;
          pageOpts = null;
          relativePath = req.params[0] || null;
          collectionName = req.params.collectionName;
          mime = req.query.mime || null;
          extension = req.query.extension || null;
          page = req.query.page || null;
          limit = (_ref1 = req.query.limit) != null ? _ref1 : null;
          offset = (_ref2 = req.query.offset) != null ? _ref2 : null;
          filter = req.query.filter;
          collection = docpad.getCollection(collectionName);
          if (!collection) {
            err = new Error("Couldn't find the collection: " + collectionName);
            return next(err);
            err;
          }
          if ((page != null) || (limit != null) || (offset != null)) {
            if (pageOpts == null) {
              pageOpts = {};
            }
            if (page != null) {
              pageOpts.page = parseInt(page, 10);
            }
            if (limit != null) {
              pageOpts.limit = parseInt(limit, 10);
            }
            if (offset != null) {
              pageOpts.offset = parseInt(offset, 10);
            }
          }
          if (filter) {
            try {
              queryOpts = JSON.parse(filter);
            } catch (_error) {
              err = _error;
              err = new Error("Failed to parse your custom filter: " + (JSON.stringify(filter)));
              return next(err);
              err;
            }
          }
          if (relativePath) {
            if (queryOpts == null) {
              queryOpts = {};
            }
            queryOpts.$or = {
              relativePath: relativePath,
              relativeDirPath: relativePath.replace(/[\/\\]+$/, '')
            };
          }
          if (extension) {
            if (queryOpts == null) {
              queryOpts = {};
            }
            queryOpts.extensions = {
              $has: extension
            };
          }
          if (mime) {
            if (queryOpts == null) {
              queryOpts = {};
            }
            queryOpts.outContentType = {
              $like: mime
            };
          }
          result = queryOpts || sortOpts || pageOpts ? collection.findAll(queryOpts, sortOpts, pageOpts) : collection;
          return next(null, result);
          return result;
        };
        deleteFilesFromRequest = function(req, next) {
          var TaskGroup;
          TaskGroup = require('taskgroup').TaskGroup;
          return getFilesFromRequest(req, function(err, files) {
            var tasks;
            if (err) {
              return next(err);
            }
            if (files.length === 0) {
              return next(null, files);
            }
            tasks = new TaskGroup().setConfig({
              concurrency: 0
            }).once('complete', function(err) {
              if (err) {
                return next(err);
              }
              return docpad.action('generate', {
                reset: false
              }, function(err) {
                return next(err, files);
              });
            });
            files.each(function(file) {
              return tasks.addTask(function(complete) {
                return file.deleteSource(function(err) {
                  if (err) {
                    return complete(err);
                  }
                  docpad.getDatabase().remove(file);
                  return complete();
                });
              });
            });
            return tasks.run();
          });
        };
        createFileFromRequest = function(req, next) {
          var collection, collectionName, collectionPath, config, docpadConfig, err, file, fileAttributes, fileMetaAttributes, fullPath, key, relativePath, value, writeSourceOptions, _ref1, _ref2;
          docpadConfig = docpad.getConfig();
          config = plugin.getConfig();
          collectionName = req.params.collectionName;
          relativePath = req.params[0];
          collection = docpad.getCollection(collectionName);
          if (!collection) {
            err = new Error("Couldn't find the collection: " + collectionName);
            return next(err);
            err;
          }
          if (!relativePath) {
            err = new Error("No relativePath to place the file specified");
            return next(err);
            err;
          }
          relativePath = getUniqueRelativePath(relativePath);
          collectionPath = plugin.getCollectionPath(collectionName);
          if (collectionPath) {
            fullPath = pathUtil.resolve(collectionPath, relativePath);
          }
          fileMetaAttributes = {};
          _ref1 = req.body;
          for (key in _ref1) {
            if (!__hasProp.call(_ref1, key)) continue;
            value = _ref1[key];
            if (key !== 'content') {
              fileMetaAttributes[key] = value;
            }
          }
          fileAttributes = {
            data: req.body.content || '',
            relativePath: relativePath,
            fullPath: fullPath,
            meta: fileMetaAttributes
          };
          file = docpad.createModel(fileAttributes);
          if ((_ref2 = config.injectHelper) != null) {
            _ref2.call(plugin, file);
          }
          writeSourceOptions = {};
          if (req.body.content != null) {
            writeSourceOptions.content = req.body.content;
          }
          file.action('writeSource', writeSourceOptions, function(err) {
            if (err) {
              return next(err, file);
            }
            return file.action('load', function(err) {
              if (err) {
                return next(err, file);
              }
              docpad.addModel(file);
              docpad.log('info', "Created file " + (file.getFilePath()) + " from request");
              return docpad.action('generate', function(err) {
                return next(err, file);
              });
            });
          });
          return file;
        };
        updateFileFromRequest = function(req, next) {
          var collection, collectionName, err, file, fileMetaAttributes, key, relativePath, setMeta, value, writeSourceOptions, _ref1;
          collectionName = req.params.collectionName;
          relativePath = req.params[0];
          collection = docpad.getCollection(collectionName);
          if (!collection) {
            err = new Error("Couldn't find the collection: " + collectionName);
            return next(err);
            err;
          }
          if (!relativePath) {
            err = new Error("No relativePath to find the file specified");
            return next(err);
            err;
          }
          file = collection.where({
            relativePath: relativePath
          })[0];
          if (!file) {
            err = new Error("Couldn't find the file at the relative path: " + relativePath);
            return next(err);
            err;
          }
          setMeta = false;
          fileMetaAttributes = {};
          _ref1 = req.body;
          for (key in _ref1) {
            if (!__hasProp.call(_ref1, key)) continue;
            value = _ref1[key];
            setMeta = true;
            if (key !== 'content') {
              fileMetaAttributes[key] = value;
            }
          }
          if (setMeta) {
            file.setMeta(fileMetaAttributes);
          }
          writeSourceOptions = {};
          if (req.body.content != null) {
            writeSourceOptions.content = req.body.content;
          }
          file.action('writeSource', writeSourceOptions, function(err) {
            if (err) {
              return next(err, file);
            }
            return file.action('load', function(err) {
              if (err) {
                return next(err, file);
              }
              docpad.log('info', "Updated file " + (file.getFilePath()) + " from request");
              return docpad.action('generate', function(err) {
                return next(err, file);
              });
            });
          });
          return file;
        };
        /*
        			# Upload a file
        			server.post "#{channel}/upload", (req, res) ->
        				# Requires
        				safefs = require('safefs')
        
        				successful = []
        				failed = []
        				currentlyUploading = []
        				count = 0
        
        				uploadFile = (file) ->
        					path = file.path
        					origName = name = docpadConfig.filesPaths[0] + '/' + file.name
        					renameCounter = 0
        
        					# save an uploaded file
        					save = ->  safefs.rename path, name, (err) ->
        						unless err
        							if renameCounter
        								successful.push
        									origName: file.name
        									newName: name.replace(docpadConfig.filesPaths[0] + '/', '')
        							else
        								successful.push
        									name: file.name
        						else
        							console.log err
        							failed.push
        								file: file.name
        								error: err
        						unless --count
        							if successful.length + failed.length is 1
        								return res.send(if successful.length then (success: successful) else (success: false, error: failed))
        							res.send
        								success: successful
        								error: failed
        
        					# Save an uploaded file with a unique name
        					saveUnique = (exists) ->
        						# Name is not unique, try again
        						if (exists or currentlyUploading.indexOf(name) > -1)
        							name = origName.replace(/(.*?)(\..*)/, '$1-' + (++renameCounter) + '$2')
        							return safefs.exists(name, saveUnique)
        						# Unique name found, let's save it
        						currentlyUploading.push(name);
        						save()
        
        					# Save each uploaded file
        					safefs.exists(name, saveUnique)
        
        				# Iterate through each uploaded file
        				for own key of req.files
        					if req.files[key].name
        						count++
        						uploadFile req.files[key]
        
        				# If no work to be done, let the user know
        				unless count
        					res.send(error: 'No Files specified')
        */

        server.all("" + channel + "/*", function(req, res, next) {
          res.header('Access-Control-Allow-Origin', '*');
          res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
          res.header('Access-Control-Allow-Headers', 'Content-Type,X-Requested-With');
          return next();
        });
        server.all("" + channel + "/template-data/", function(req, res) {
          var result;
          result = docpad.getTemplateData();
          return sendSuccessData(res, result, "Listing of template data completed successfully");
        });
        server.all("" + channel + "/files/", function(req, res) {
          return res.redirect(301, "" + channel + "/collection/database/");
        });
        server.all("" + channel + "/file/*", function(req, res) {
          return res.redirect(301, "" + channel + "/collection/database/" + req.params[0]);
        });
        server.all("" + channel + "/collections/", function(req, res) {
          var result;
          result = prepareCollections();
          return sendSuccessData(res, result, "Listing of collections completed successfully");
        });
        server.all("" + channel + "/collection/:collectionName/*", function(req, res) {
          var additionalFields, collectionName, err, method, relativePath;
          method = req.method.toLowerCase();
          if (method === 'get') {
            collectionName = req.params.collectionName;
            relativePath = req.params[0];
            additionalFields = req.query.additionalFields || req.query.additionalfields;
            getFilesFromRequest(req, function(err, files) {
              if (err) {
                return sendError(res, err);
              }
              return sendSuccessData(res, prepareCollection(files, additionalFields), "Listing of " + collectionName + " at " + relativePath + " completed successfully");
            });
          } else if (method === 'delete') {
            deleteFilesFromRequest(req, function(err, files) {
              if (err) {
                return sendError(res, err);
              }
              return sendSuccessData(res, prepareCollection(files, additionalFields), "Delete completed successfully");
            });
          } else if (method === 'put') {
            additionalFields = req.query.additionalFields || req.query.additionalfields;
            createFileFromRequest(req, function(err, file) {
              if (err) {
                return sendError(res, err);
              }
              return sendSuccessData(res, prepareFile(file, additionalFields), "Creation completed successfully");
            });
          } else if (method === 'post') {
            additionalFields = req.query.additionalFields || req.query.additionalfields;
            updateFileFromRequest(req, function(err, file) {
              if (err) {
                return sendError(res, err);
              }
              return sendSuccessData(res, prepareFile(file, additionalFields), "Update completed successfully");
            });
          } else {
            err = Error("Unknown method: " + method);
            sendError(res, err);
          }
        });
        return this;
      };

      return RestAPI;

    })(BasePlugin);
  };

}).call(this);
